<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Feng~Lin">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Feng~Lin">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feng~Lin">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Feng~Lin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Feng~Lin</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/12/React/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/12/React/" itemprop="url">
                  React 技术栈
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-12T00:00:00+08:00">
                2016-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="title-React-技术栈"><a href="#title-React-技术栈" class="headerlink" title="title: React 技术栈"></a>title: React 技术栈</h2><p>React 是目前最热门的前端框架</p>
<p>Facebook 公司2013年推出</p>
<p>现在最好的社区支持和生态圈</p>
<p>大量的第三方工具<br><img src="https://github.com/ruanyf/jstraining/blob/master/docs/images/react-logo.png?raw=true" alt="Generating"></p>
<h2 id="React-的优点"><a href="#React-的优点" class="headerlink" title="React 的优点"></a>React 的优点</h2><p>组件模式：代码复用和团队分工</p>
<p>虚拟 DOM：性能优势</p>
<p>移动端支持：跨终端</p>
<h2 id="React-的缺点"><a href="#React-的缺点" class="headerlink" title="React 的缺点"></a>React 的缺点</h2><p>学习曲线较陡峭</p>
<p>全新的一套概念，与其他所有框架截然不同</p>
<p>只有采用它的整个技术栈，才能发挥最大威力</p>
<p>More info: React 非常先进和强大，但是学习和实现成本都不低</p>
<h3 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h3><p>React 使用 JSX 语法，JavaScript 代码中可以写 HTML 代码。</p>
<figure class="highlight plain"><figcaption><span>myTitle = <h1>Hello, world!</h1>;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line"></div><div class="line">### JSX 语法解释</div><div class="line">（1）JSX 语法的最外层，只能有一个节点。</div><div class="line"></div><div class="line">``` </div><div class="line">// 错误</div><div class="line">let myTitle = &lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;;</div></pre></td></tr></table></figure>
<p>（2）JSX 语法中可以插入 JavaScript 代码，使用大括号。</p>
<figure class="highlight plain"><figcaption><span>myTitle = <p>&#123;'Hello ' + 'World'&#125;</p></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line">### Babel 转码器</div><div class="line">JavaScript 引擎（包括浏览器和 Node）都不认识 JSX，需要首先使用 Babel 转码，然后才能运行。</div><div class="line"></div><div class="line">React 需要加载两个库：React 和 React-DOM，前者是 React 的核心库，后者是 React 的 DOM 适配库。</div><div class="line"></div><div class="line">Babel 用来在浏览器转换 JSX 语法，如果服务器已经转好了，浏览器就不需要加载这个库。</div><div class="line"></div><div class="line">## React 组件</div><div class="line">#### 实验目的</div><div class="line">学会通过状态变动，引发组件的重新渲染。</div><div class="line">#### 操作步骤</div><div class="line">浏览器打开demos/react-component-demo/index3.html，仔细查看源码。</div><div class="line">#### 注意事项</div></pre></td></tr></table></figure>
<p> class MyTitle extends React.Component {<br>    constructor(…args) {<br>      super(…args);<br>      this.state = {<br>        name: ‘访问者’<br>      };<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">constructor是组件的构造函数，会在创建实例时自动调用。...args表示组件参数，super(...args)是 ES6 规定的写法。this.state对象用来存放内部状态，这里是定义初始状态。</div><div class="line"></div><div class="line">```&lt;div&gt;</div><div class="line">  &lt;input</div><div class="line">    type=&quot;text&quot;</div><div class="line">    onChange=&#123;this.handleChange.bind(this)&#125;</div><div class="line">  /&gt;</div><div class="line">  &lt;p&gt;你好，&#123;this.state.name&#125;&lt;/p&gt;</div><div class="line">&lt;/div&gt;;</div></pre></td></tr></table></figure></p>
<p>this.state.name表示读取this.state的name属性。每当输入框有变动，就会自动调用onChange指定的监听函数，这里是this.handleChange，.bind(this)表示该方法内部的this，绑定当前组件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/14/sass语法/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/14/sass语法/" itemprop="url">
                  sass入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-14T00:00:00+08:00">
                2016-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="sass语法"><a href="#sass语法" class="headerlink" title="sass语法"></a>sass语法</h3><p>关于sass 3.3.0更新说明————<a href="http://sass-lang.com/documentation/file.SASS_CHANGELOG.html#330_7_march_2014" target="_blank" rel="external">3.3.0</a></p>
<h3 id="文件后缀名"><a href="#文件后缀名" class="headerlink" title="文件后缀名"></a>文件后缀名</h3><hr>
<h4 id="sass有两种后缀名文件："><a href="#sass有两种后缀名文件：" class="headerlink" title="sass有两种后缀名文件："></a>sass有两种后缀名文件：</h4><ul>
<li>一种后缀名为sass，不使用大括号和分号；</li>
<li>另一种就是我们这里使用的scss文件，这种和我们平时写的css文件格式差不多，使用大括号和分号。</li>
</ul>
<p>而本教程中所说的所有sass文件都指后缀名为scss的文件。在此也建议使用后缀名为scss的文件，以避免sass后缀名的严格格式要求报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//文件后缀名为sass的语法</div><div class="line">body</div><div class="line">  background: #eee</div><div class="line">  font-size:12px</div><div class="line">p</div><div class="line">  background: #0982c1</div><div class="line"></div><div class="line">//文件后缀名为scss的语法  </div><div class="line">body &#123;</div><div class="line">  background: #eee;</div><div class="line">  font-size:12px;</div><div class="line">&#125;</div><div class="line">p&#123;</div><div class="line">  background: #0982c1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>sass的导入(@import)规则和CSS的有所不同，编译时会将@import的scss文件合并进来只生成一个CSS文件。但是如果你在sass文件中导入css文件如@import ‘reset.css’，那效果跟普通CSS导入样式文件一样，导入的css文件不会合并到编译后的文件中，而是以@import方式存在。</p>
<p>所有的sass导入文件都可以忽略后缀名.scss。一般来说基础的文件命名方法以_开头，如_mixin.scss。这种文件在导入的时候可以不写下划线，可写成@import “mixin”。</p>
<h4 id="被导入sass文件a-scss："><a href="#被导入sass文件a-scss：" class="headerlink" title="被导入sass文件a.scss："></a>被导入sass文件a.scss：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//a.scss</div><div class="line">//-------------------------------</div><div class="line">body &#123;</div><div class="line">  background: #eee;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="需要导入样式的sass文件b-scss："><a href="#需要导入样式的sass文件b-scss：" class="headerlink" title="需要导入样式的sass文件b.scss："></a>需要导入样式的sass文件b.scss：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@import &quot;reset.css&quot;;</div><div class="line">@import &quot;a&quot;;</div><div class="line">p&#123;</div><div class="line">  background: #0982c1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="转译出来的b-css样式："><a href="#转译出来的b-css样式：" class="headerlink" title="转译出来的b.css样式："></a>转译出来的b.css样式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@import &quot;reset.css&quot;;</div><div class="line">body &#123;</div><div class="line">  background: #eee;</div><div class="line">&#125;</div><div class="line">p&#123;</div><div class="line">  background: #0982c1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据上面的代码可以看出，b.scss编译后，reset.css继续保持import的方式，而a.scss则被整合进来了。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>sass有两种注释方式，一种是标准的css注释方式/<em> </em>/，另一种则是//双斜杆形式的单行注释，不过这种单行注释不会被转译出来。</p>
<p>标准的css注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*我是css的标准注释</div><div class="line">*设置body内距</div><div class="line">*/</div><div class="line">body&#123;</div><div class="line">  padding:5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="双斜杆单行注释"><a href="#双斜杆单行注释" class="headerlink" title="双斜杆单行注释"></a>双斜杆单行注释</h4><p>单行注释跟JavaScript语言中的注释一样，使用又斜杠（//），但单行注释不会输入到CSS中。<br>//我是双斜杠表示的单行注释<br>//设置body内距</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">  padding:5px; //5px</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>sass的变量必须是$开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样），如果值后面加上!default则表示默认值。</p>
<h4 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h4><p>定义之后可以在全局范围内使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//sass style</div><div class="line">//-------------------------------</div><div class="line">$fontSize: 12px;</div><div class="line">body&#123;</div><div class="line">    font-size:$fontSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//css style</div><div class="line">//-------------------------------</div><div class="line">body&#123;</div><div class="line">    font-size:12px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h4><p>sass的默认变量仅需要在值后面加上!default即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//sass style</div><div class="line">//-------------------------------</div><div class="line">$baseLineHeight:        1.5 !default;</div><div class="line">body&#123;</div><div class="line">    line-height: $baseLineHeight; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//css style</div><div class="line">//-------------------------------</div><div class="line">body&#123;</div><div class="line">    line-height:1.5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//sass style</div><div class="line">//-------------------------------</div><div class="line">$baseLineHeight:        2;</div><div class="line">$baseLineHeight:        1.5 !default;</div><div class="line">body&#123;</div><div class="line">    line-height: $baseLineHeight; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//css style</div><div class="line">//-------------------------------</div><div class="line">body&#123;</div><div class="line">    line-height:2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/19/nodeJs/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/19/nodeJs/" itemprop="url">
                  nodeJS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-19T00:00:00+08:00">
                2016-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="title-nodeJS"><a href="#title-nodeJS" class="headerlink" title="title: nodeJS"></a>title: nodeJS</h2><h2 id="我的nodejs之路"><a href="#我的nodejs之路" class="headerlink" title="我的nodejs之路"></a>我的nodejs之路</h2><h3 id="fs模块–文件系统API"><a href="#fs模块–文件系统API" class="headerlink" title="fs模块–文件系统API"></a>fs模块–文件系统API</h3><p>File System<br>简介：文件模块是一个简单包装POSIX文件I/O操作方法集。可以通过调用require(‘fs’)来获取该模块。文件系统模块中的所有方法均有异步和同步<br>异步同步的区别：<br>异步：需要一个完成时的回调函数作为最后一个传入形参。回调函数的构成由调用的异步方法所决定，通常情况下回调函数的第一个形参为返回的错误信息。同时，使用异步版本不能保证执行顺序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.asy(<span class="string">'../hello'</span>,<span class="keyword">function</span>(err)&#123;</div><div class="line">	<span class="keyword">if</span>(err) throw err;</div><div class="line">	console.log(<span class="string">'success'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>同步：如果您使用的是同步版本的操作方法，则一旦出现错误，会以通常的抛出错误的形式返回错误。 你可以用try和catch等语句来拦截错误并使程序继续进行。<br>    fs.sy(‘../hello’)<br>    console.log(‘success’);<br><!--核心模块引用--><br>var fs =require(‘fs);<br>1、读取文件readFile函数<br>readFile(filename,[options],callback);<br> filename, 必选参数，文件名<br> [options],可选参数，<br> callback 读取文件之后执行的回调函数，参数默认第一个err,第二个data<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readFile(__dirname + <span class="string">'/test.js'</span>, &#123;<span class="string">'utf8'</span>&#125;, <span class="keyword">function</span> (err, data) &#123;</div><div class="line">    <span class="keyword">if</span>(err) &#123;</div><div class="line">     console.error(err);</div><div class="line">     <span class="built_in">return</span>;</div><div class="line">    &#125;</div><div class="line">    console.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/20/利用CSS、JavaScript及Ajax实现图片预加载/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/20/利用CSS、JavaScript及Ajax实现图片预加载/" itemprop="url">
                  利用CSS、JavaScript及Ajax实现图片预加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-20T00:00:00+08:00">
                2016-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。</p>
<p>单纯的使用css可以将图片加载到页面元素的背景上，这种方法简单、高效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#preload-01 &#123; background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; &#125;</div><div class="line">#preload-02 &#123; background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; &#125;</div><div class="line">#preload-03 &#123; background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; &#125;</div></pre></td></tr></table></figure>
<p>将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。</p>
<p>弊端：该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function preloader() &#123;</div><div class="line">    if (document.getElementById) &#123;</div><div class="line">        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;;</div><div class="line">        document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(http://domain.tld/image-02.png) no-repeat -9999px -9999px&quot;;</div><div class="line">        document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(http://domain.tld/image-03.png) no-repeat -9999px -9999px&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function addLoadEvent(func) &#123;</div><div class="line">    var oldonload = window.onload;</div><div class="line">    if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">        window.onload = func;</div><div class="line">    &#125; else &#123;</div><div class="line">        window.onload = function() &#123;</div><div class="line">            if (oldonload) &#123;</div><div class="line">                oldonload();</div><div class="line">            &#125;</div><div class="line">            func();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addLoadEvent(preloader);</div></pre></td></tr></table></figure>
<p>在该脚本的第一部分，我们获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。</p>
<p>该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。</p>
<p>如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。</p>
<h3 id="使用JavaScript实现"><a href="#使用JavaScript实现" class="headerlink" title="使用JavaScript实现"></a>使用JavaScript实现</h3><p>上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;hidden&quot;&gt;</div><div class="line">  		&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">           var images = new Array()</div><div class="line">           function preload() &#123;</div><div class="line">               for (i = 0; i &lt; preload.arguments.length; i++) &#123;</div><div class="line">                   images[i] = new Image()</div><div class="line">                   images[i].src = preload.arguments[i]</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           preload(</div><div class="line">               &quot;http://domain.tld/gallery/image-001.jpg&quot;,</div><div class="line">               &quot;http://domain.tld/gallery/image-002.jpg&quot;,</div><div class="line">               &quot;http://domain.tld/gallery/image-003.jpg&quot;</div><div class="line">           )</div><div class="line">           &lt;/script&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>该方法尤其适用预加载大量的图片。我的画廊网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>该方法与上面的方法类似，也可以预加载任意数量的图片。将下面的脚本添加入任何Web页中，根据程序指令进行编辑即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;hidden&quot;&gt;</div><div class="line">   	&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">           if (document.images) &#123;</div><div class="line">               img1 = new Image();</div><div class="line">               img2 = new Image();</div><div class="line">               img3 = new Image();</div><div class="line">               img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;;</div><div class="line">               img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;;</div><div class="line">               img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;;</div><div class="line">           &#125;</div><div class="line">  		&lt;/script&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = “../path/to/image-003.gif”;”。参考该模式，你可根据需要加载任意多的图片。</p>
<p>我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function preloader() &#123;</div><div class="line">    if (document.images) &#123;</div><div class="line">        var img1 = new Image();</div><div class="line">        var img2 = new Image();</div><div class="line">        var img3 = new Image();</div><div class="line">        img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;;</div><div class="line">        img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;;</div><div class="line">        img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function addLoadEvent(func) &#123;</div><div class="line">    var oldonload = window.onload;</div><div class="line">    if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">        window.onload = func;</div><div class="line">    &#125; else &#123;</div><div class="line">        window.onload = function() &#123;</div><div class="line">            if (oldonload) &#123;</div><div class="line">                oldonload();</div><div class="line">            &#125;</div><div class="line">            func();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addLoadEvent(preloader);</div></pre></td></tr></table></figure>
<h2 id="使用Ajax"><a href="#使用Ajax" class="headerlink" title="使用Ajax"></a>使用Ajax</h2><p>上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">window.onload = function() &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        // XHR to request a JS and a CSS</div><div class="line">        var xhr = new XMLHttpRequest();</div><div class="line">        xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.js&apos;);</div><div class="line">        xhr.send(&apos;&apos;);</div><div class="line">        xhr = new XMLHttpRequest();</div><div class="line">        xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.css&apos;);</div><div class="line">        xhr.send(&apos;&apos;);</div><div class="line">        // preload image</div><div class="line">        new Image().src = &quot;http://domain.tld/preload.png&quot;;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。</p>
<p>下面，我们看看如何用JavaScript来实现该加载过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">	window.onload = function() &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        // reference to &lt;head&gt;</div><div class="line">        var head = document.getElementsByTagName(&apos;head&apos;)[0];</div><div class="line">        // a new CSS</div><div class="line">        var css = document.createElement(&apos;link&apos;);</div><div class="line">        css.type = &quot;text/css&quot;;</div><div class="line">        css.rel  = &quot;stylesheet&quot;;</div><div class="line">        css.href = &quot;http://domain.tld/preload.css&quot;;</div><div class="line">        // a new JS</div><div class="line">        var js  = document.createElement(&quot;script&quot;);</div><div class="line">        js.type = &quot;text/javascript&quot;;</div><div class="line">        js.src  = &quot;http://domain.tld/preload.js&quot;;</div><div class="line">        // preload JS and CSS</div><div class="line">        head.appendChild(css);</div><div class="line">        head.appendChild(js);</div><div class="line">        // preload image</div><div class="line">        new Image().src = &quot;http://domain.tld/preload.png&quot;;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/30/预加载/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/30/预加载/" itemprop="url">
                  利用CSS、JavaScript及Ajax实现图片预加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-30T00:00:00+08:00">
                2016-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。</p>
<p>单纯的使用css可以将图片加载到页面元素的背景上，这种方法简单、高效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#preload-01 &#123; background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; &#125;</div><div class="line">#preload-02 &#123; background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; &#125;</div><div class="line">#preload-03 &#123; background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; &#125;</div></pre></td></tr></table></figure>
<p>将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。</p>
<p>弊端：该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function preloader() &#123;</div><div class="line">    if (document.getElementById) &#123;</div><div class="line">        document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;;</div><div class="line">        document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(http://domain.tld/image-02.png) no-repeat -9999px -9999px&quot;;</div><div class="line">        document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(http://domain.tld/image-03.png) no-repeat -9999px -9999px&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function addLoadEvent(func) &#123;</div><div class="line">    var oldonload = window.onload;</div><div class="line">    if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">        window.onload = func;</div><div class="line">    &#125; else &#123;</div><div class="line">        window.onload = function() &#123;</div><div class="line">            if (oldonload) &#123;</div><div class="line">                oldonload();</div><div class="line">            &#125;</div><div class="line">            func();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addLoadEvent(preloader);</div></pre></td></tr></table></figure>
<p>在该脚本的第一部分，我们获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。</p>
<p>该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。</p>
<p>如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。</p>
<h3 id="使用JavaScript实现"><a href="#使用JavaScript实现" class="headerlink" title="使用JavaScript实现"></a>使用JavaScript实现</h3><p>上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;hidden&quot;&gt;</div><div class="line">  		&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">           var images = new Array()</div><div class="line">           function preload() &#123;</div><div class="line">               for (i = 0; i &lt; preload.arguments.length; i++) &#123;</div><div class="line">                   images[i] = new Image()</div><div class="line">                   images[i].src = preload.arguments[i]</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           preload(</div><div class="line">               &quot;http://domain.tld/gallery/image-001.jpg&quot;,</div><div class="line">               &quot;http://domain.tld/gallery/image-002.jpg&quot;,</div><div class="line">               &quot;http://domain.tld/gallery/image-003.jpg&quot;</div><div class="line">           )</div><div class="line">           &lt;/script&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>该方法尤其适用预加载大量的图片。我的画廊网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>该方法与上面的方法类似，也可以预加载任意数量的图片。将下面的脚本添加入任何Web页中，根据程序指令进行编辑即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;hidden&quot;&gt;</div><div class="line">   	&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">           if (document.images) &#123;</div><div class="line">               img1 = new Image();</div><div class="line">               img2 = new Image();</div><div class="line">               img3 = new Image();</div><div class="line">               img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;;</div><div class="line">               img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;;</div><div class="line">               img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;;</div><div class="line">           &#125;</div><div class="line">  		&lt;/script&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = “../path/to/image-003.gif”;”。参考该模式，你可根据需要加载任意多的图片。</p>
<p>我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function preloader() &#123;</div><div class="line">    if (document.images) &#123;</div><div class="line">        var img1 = new Image();</div><div class="line">        var img2 = new Image();</div><div class="line">        var img3 = new Image();</div><div class="line">        img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;;</div><div class="line">        img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;;</div><div class="line">        img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function addLoadEvent(func) &#123;</div><div class="line">    var oldonload = window.onload;</div><div class="line">    if (typeof window.onload != &apos;function&apos;) &#123;</div><div class="line">        window.onload = func;</div><div class="line">    &#125; else &#123;</div><div class="line">        window.onload = function() &#123;</div><div class="line">            if (oldonload) &#123;</div><div class="line">                oldonload();</div><div class="line">            &#125;</div><div class="line">            func();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addLoadEvent(preloader);</div></pre></td></tr></table></figure>
<h2 id="使用Ajax"><a href="#使用Ajax" class="headerlink" title="使用Ajax"></a>使用Ajax</h2><p>上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">window.onload = function() &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        // XHR to request a JS and a CSS</div><div class="line">        var xhr = new XMLHttpRequest();</div><div class="line">        xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.js&apos;);</div><div class="line">        xhr.send(&apos;&apos;);</div><div class="line">        xhr = new XMLHttpRequest();</div><div class="line">        xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.css&apos;);</div><div class="line">        xhr.send(&apos;&apos;);</div><div class="line">        // preload image</div><div class="line">        new Image().src = &quot;http://domain.tld/preload.png&quot;;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。</p>
<p>下面，我们看看如何用JavaScript来实现该加载过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">	window.onload = function() &#123;</div><div class="line">    setTimeout(function() &#123;</div><div class="line">        // reference to &lt;head&gt;</div><div class="line">        var head = document.getElementsByTagName(&apos;head&apos;)[0];</div><div class="line">        // a new CSS</div><div class="line">        var css = document.createElement(&apos;link&apos;);</div><div class="line">        css.type = &quot;text/css&quot;;</div><div class="line">        css.rel  = &quot;stylesheet&quot;;</div><div class="line">        css.href = &quot;http://domain.tld/preload.css&quot;;</div><div class="line">        // a new JS</div><div class="line">        var js  = document.createElement(&quot;script&quot;);</div><div class="line">        js.type = &quot;text/javascript&quot;;</div><div class="line">        js.src  = &quot;http://domain.tld/preload.js&quot;;</div><div class="line">        // preload JS and CSS</div><div class="line">        head.appendChild(css);</div><div class="line">        head.appendChild(js);</div><div class="line">        // preload image</div><div class="line">        new Image().src = &quot;http://domain.tld/preload.png&quot;;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/20/JS中的call、apply、bind方法/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/20/JS中的call、apply、bind方法/" itemprop="url">
                  JS中的call、applay、bind方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-20T00:00:00+08:00">
                2016-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="title-JS中的call、applay、bind方法"><a href="#title-JS中的call、applay、bind方法" class="headerlink" title="title: JS中的call、applay、bind方法"></a>title: JS中的call、applay、bind方法</h2><p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向。</p>
<hr>
<p>call、apply、bind方法的共同点和区别：<br>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；<br>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；<br>apply 、 call 、bind 三者都可以利用后续参数传参；<br>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
<hr>
<h2 id="一、call"><a href="#一、call" class="headerlink" title="一、call"></a>一、call</h2><p>call()<br>语法：</p>
<figure class="highlight plain"><figcaption><span>arg2[, [,.argN]]]]])```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">定义：调用一个对象的一个方法，以另一个对象替换当前对象。</div><div class="line"></div><div class="line">说明： call 方法可以用来代替另一个对象调用一个方法。</div><div class="line">call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</div><div class="line"></div><div class="line">thisObj的取值有以下4种情况：</div><div class="line"></div><div class="line">*  不传，或者传null,undefined， 函数中的this指向window对象</div><div class="line">*  传递另一个函数的函数名，函数中的this指向这个函数的引用</div><div class="line">*  传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean</div><div class="line">*  传递一个对象，函数中的this指向这个对象</div></pre></td></tr></table></figure>
<p>function a(){<br>  console.log(this);   //输出函数a中的this对象<br>}       </p>
<p>function b(){}       </p>
<p>var c={name:”call”};    //定义对象c  </p>
<p>a.call();   //window<br>a.call(null);   //window<br>a.call(undefined);   //window<br>a.call(1);   //Number<br>a.call(‘’);   //String<br>a.call(true);   //Boolean<br>a.call(b);   //function b(){}<br>a.call(c);   //Object<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果你不理解上面的，没关系，我们再来看一个例子：</div></pre></td></tr></table></figure></p>
<p>function class1(){<br>  this.name=function(){<br>    console.log(“我是class1内的方法”);<br>  }<br>}<br>function class2(){<br>  class1.call(this);  //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）<br>}   </p>
<p>var f=new class2();<br>f.name();   //调用的是class1内的方法，将class1的name方法交给class2使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">常用例子：</div><div class="line">（1）</div></pre></td></tr></table></figure></p>
<p>function eat(x,y){<br>  console.log(x+y);<br>}<br>function drink(x,y){<br>  console.log(x-y);<br>}<br>eat.call(drink,3,2);</p>
<p>输出：5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2) ，所以运行结果为：console.log(5);</div><div class="line">注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</div><div class="line">（2）</div></pre></td></tr></table></figure></p>
<p>function Animal(){<br>  this.name=”animal”;<br>  this.showName=function(){<br>    console.log(this.name);<br>  }<br>}<br>function Dog(){<br>  this.name=”dog”;<br>}<br>var animal=new Animal();<br>var dog=new Dog();       </p>
<p>animal.showName.call(dog);</p>
<p>输出：dog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？</div><div class="line"></div><div class="line">关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。</div><div class="line"></div><div class="line">（3）继承</div></pre></td></tr></table></figure></p>
<p>function Animal(name){<br>  this.name=name;<br>  this.showName=function(){<br>    console.log(this.name);<br>  }<br>}<br>function Dog(name){<br>  Animal.call(this,name);<br>}<br>var dog=new Dog(“Crazy dog”);<br>dog.showName();</p>
<p>输出：Crazy dog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。</div><div class="line"></div><div class="line">二、apply()</div><div class="line">语法：```apply([thisObj[,argArray]])</div></pre></td></tr></table></figure></p>
<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</p>
<p>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<p>call 和 apply的区别<br>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function class1(args1,args2)&#123;       </div><div class="line">  this.name=function()&#123;      </div><div class="line">   console.log(args,args);      </div><div class="line">  &#125;     </div><div class="line">&#125;     </div><div class="line">function class2()&#123;    </div><div class="line">  var args1=&quot;1&quot;;</div><div class="line">  var args2=&quot;2&quot;;</div><div class="line">  class1.call(this,args1,args2);  </div><div class="line">  /*或*/</div><div class="line">  class1.apply(this,[args1,args2]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var c=new class2();   </div><div class="line">c.name();</div><div class="line"></div><div class="line">输出：1 2</div></pre></td></tr></table></figure>
<p>call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</p>
<p>既然两者功能一样，那该用哪个呢？</p>
<p>在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call ；而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个类数组对象来遍历所有的参数。</p>
<p>三、bind</p>
<p>bind是在EcmaScript5中扩展的方法（IE6,7,8不支持）<br>bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。</p>
<p>　　MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>注意：bind方法的返回值是函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var bar=function()&#123;   </div><div class="line">  console.log(this.x);   </div><div class="line">&#125;</div><div class="line">var foo=&#123; </div><div class="line">     x:3   </div><div class="line">&#125;   </div><div class="line">bar();  </div><div class="line">bar.bind(foo)();</div><div class="line"> /*或*/</div><div class="line">var func=bar.bind(foo);   </div><div class="line">func();</div><div class="line"></div><div class="line">输出：</div><div class="line">undefined</div><div class="line">3</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/11/Ajax/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/Ajax/" itemprop="url">
                  Ajax语法浅析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ajax是目前很普遍的一门技术，也是很值得探讨和研究的一门技术。本文将针对Ajax的发展过程并结合其在不同库框架中的使用方式来和大家分享下Ajax的那些新老语法。</p>
<h2 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h2><p>Ajax全称为“Asynchronous Javascript And XML”，即“异步javascript和XML”的意思。通过Ajax我们可以向服务器发送请求，在不阻塞页面的情况下进行数据交互，也可以理解为异步数据传输。在Ajax的帮助下我们的网页只需局部刷新即可更新数据的显示，减少了不少必要的数据量，大大提高了用户体验，缩短了用户等待的时间，使得web应用程序更小、更快、更友好。</p>
<h3 id="原生Ajax"><a href="#原生Ajax" class="headerlink" title="原生Ajax"></a>原生Ajax</h3><p>基本上现在的所有浏览器都支持原生Ajax的功能，下面就详细介绍利用原生js我们怎样来发起和处理Ajax请求。</p>
<h4 id="1-获取XMLHttpRequest对象"><a href="#1-获取XMLHttpRequest对象" class="headerlink" title="1.获取XMLHttpRequest对象"></a>1.获取XMLHttpRequest对象</h4><p><code>var xhr =new XMLHttpRequest();//获取浏览器内置的XMLHttpRequest对象</code></p>
<p>如果你的项目应用不考虑低版本IE，那么可以直接用上面的方法，所有现代浏览器 (Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。如果需要兼容老版本IE（IE5、IE6），那么可以使用 ActiveX 对象:</p>
<pre><code>var xhr;
if (window.XMLHttpRequest) {
xhr=new XMLHttpRequest();
} else if (window.ActiveXObject) { // 兼容老版本浏览器
xhr=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
</code></pre><h4 id="2-参数配置"><a href="#2-参数配置" class="headerlink" title="2.参数配置"></a>2.参数配置</h4><p>有了XMLHttpRequest对象，我们还需要配置一些请求的参数信息来完成数据交互，利用open方法即可:</p>
<pre><code>var xhr;
if(window.XMLHttpRequest){
    xhr=new XMLHttpRequest();
}else if(window.ActiveXObject){
    xhr=new ActiveXObject(&quot;Microsoft&quot;)
}
if(xhr){
    xhr.open(&apos;GET&apos;,&apos;/TEST/&apos;,true);//以GET请求的方式向&apos;/test/&apos;路径发送异步请求
}
</code></pre><p>open方法为我们创建了一个新的http请求，其中第一个参数为请求方式，一般为’GET’或’POST’;第二个参数为请求URL;第三个参数为是否异步，默认为true。</p>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>配置完了基本参数信息，我们直接调用send方法发送请求，代码如下:</p>
<pre><code>var xhr;
if(window.XMLHttpRequest){
    xhr=new XMLHttpRequest();
}else if(window.ActiveXObject){
    xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
if(xhr){
    xhr.open(&apos;GET&apos;,&apos;&apos;/test/&apos;,true);//以GET请求的方式向&apos;/test/&apos;路径发送异步请求
    xhr.send();//调用send方法发送请求
}
</code></pre><p>你需要注意的是如果使用GET方法传递参数，我们可以直接将参数放在URL后面，比如’/test/?username=fl&amp;pwd=666’;如果使用POST方法，那么我们的参数需要写在send方法里</p>
<pre><code>xhr.open(&apos;POST&apos;,&apos;/test/&apos;,true);
xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//将请求头设置为表单方式提交
xhr.send(&apos;username=fl&amp;pwd=666&apos;);
</code></pre><p>最终会以Form Data的形式传递,因此我们要修改成我们期望的数据格式JSON格式。</p>
<pre><code>xhr.open(&apos;POST&apos;,&apos;/test/&apos;,true);
xhr.send(JSON.stringify({username:&apos;fl&apos;,pwd:666}));
</code></pre><h4 id="监测状态"><a href="#监测状态" class="headerlink" title="监测状态"></a>监测状态</h4><p>发送完Ajax请求之后，我们需要针对服务器返回的状态进行监测并进行相应的处理，这里我们需要使用onreadystatechange方法。<br>代码如下：</p>
<pre><code>var xhr;
if(window.XMLHttpRequest){
    xhr=new XMLHttpRequest();
}else if(window.ActiveXObject){
    xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);
}
if(xhr){
    xhr.open(&apos;GET&apos;,&apos;/test/&apos;,true);//以get请求的方式向&apos;/test/&apos;路径发送异步请求
    xhr.send();
    xhr.onreadystatechange = function(){//利用onreadystatechange检测状态
        if(xhr.readyState ==4){//readyState为4表示请求响应完成
            if(xhr.status ===200){//status为200表示请求成功
                console.log(&apos;执行成功&apos;);
            }else{
                console.log(&apos;执行出错&apos;);
            }
        }
    }
}
</code></pre><p>上面我们利用onreadystatechange监测状态，并在内部利用readyState获取当前的状态。readyState一共有5个阶段，当其为4时表示响应内容解析完成，可以在客户端调用了。当readyState为4时，我们又通过status来获取状态码，状态码为200时执行成功代码，否则执行出错代码。</p>
<p>当然我们可以用onload来代替onreadystatechange等于4的情况，因为onload只在状态为4的时候才被调用，代码如下：</p>
<pre><code>xhr.onload = function () {    // 调用onload           if (xhr.status === 200) {    // status为200表示请求成功
    }
        console.log(&apos;执行成功&apos;);
    } else {
    console.log(&apos;执行出错&apos;);
    }   
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/10/ajax简介/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/10/ajax简介/" itemprop="url">
                  Ajax 完整教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-10T00:00:00+08:00">
                2016-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ajax 由 HTML、JavaScript™ 技术、DHTML 和 DOM 组成，这一杰出的方法可以将笨拙的 Web 界面转化成交互性的 Ajax 应用程序。本文的作者是一位 Ajax 专家，他演示了这些技术如何协同工作 —— 从总体概述到细节的讨论 —— 使高效的 Web 开发成为现实。他还揭开了 Ajax 核心概念的神秘面纱，包括 XMLHttpRequest 对象。</p>
<p>五年前，如果不知道 XML，您就是一只无人重视的丑小鸭。十八个月前，Ruby 成了关注的中心，不知道 Ruby 的程序员只能坐冷板凳了。今天，如果想跟上最新的技术时尚，那您的目标就是 Ajax。</p>
<h2 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h2><p>Ajax 不仅仅 是一种时尚，它是一种构建网站的强大方法，而且不像学习一种全新的语言那样困难。</p>
<p>但在详细探讨 Ajax 是什么之前，先让我们花几分钟了解 Ajax 做 什么。目前，编写应用程序时有两种基本的选择：</p>
<h3 id="·桌面应用程序和·Web-应用程序"><a href="#·桌面应用程序和·Web-应用程序" class="headerlink" title="·桌面应用程序和·Web 应用程序"></a>·桌面应用程序和·Web 应用程序</h3><p>两者是类似的，桌面应用程序通常以 CD 为介质（有时候可从网站下载）并完全安装到您的计算机上。桌面应用程序可能使用互联网下载更新，但运行这些应用程序的代码在桌面计算机上。Web 应用程序运行在某处的 Web 服务器上 —— 毫不奇怪，要通过 Web 浏览器访问这种应用程序。</p>
<p>不过，比这些应用程序的运行代码放在何处更重要的是，应用程序如何运转以及如何与其进行交互。桌面应用程序一般很快（就在您的计算机上运行，不用等待互联网连接），具有漂亮的用户界面（通常和操作系统有关）和非凡的动态性。可以单击、选择、输入、打开菜单和子菜单、到处巡游，基本上不需要等待。</p>
<p>另一方面，Web 应用程序是最新的潮流，它们提供了在桌面上不能实现的服务（比如 Amazon.com 和 eBay）。但是，伴随着 Web 的强大而出现的是等待，等待服务器响应，等待屏幕刷新，等待请求返回和生成新的页面。</p>
<p>显然这样说过于简略了，但基本的概念就是如此。您可能已经猜到，Ajax 尝试建立桌面应用程序的功能和交互性，与不断更新的 Web 应用程序之间的桥梁。可以使用像桌面应用程序中常见的动态用户界面和漂亮的控件，不过是在 Web 应用程序中。</p>
<p>还等什么呢？我们来看看 Ajax 如何将笨拙的 Web 界面转化成能迅速响应的 Ajax 应用程序吧。</p>
<p>老技术，新技巧</p>
<p>在谈到 Ajax 时，实际上涉及到多种技术，要灵活地运用它必须深入了解这些不同的技术（本系列的头几篇文章将分别讨论这些技术）。好消息是您可能已经非常熟悉其中的大部分技术，更好的是这些技术都很容易学习，并不像完整的编程语言（如 Java 或 Ruby）那样困难。</p>
<h4 id="Ajax应用程序用到的技术"><a href="#Ajax应用程序用到的技术" class="headerlink" title="Ajax应用程序用到的技术"></a>Ajax应用程序用到的技术</h4><figure class="highlight plain"><figcaption><span>用于建立 Web 表单并确定应用程序其他部分使用的字段。 </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line">```·JavaScript 代码是运行 Ajax 应用程序的核心代码，帮助改进与服务器应用程序的通信。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>或 Dynamic HTML，用于动态更新表单。我们将使用 div、span 和其他动态 HTML 元素来标记 HTML。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line"></div><div class="line">```·文档对象模型 DOM 用于（通过 JavaScript 代码）处理 HTML 结构和（某些情况下）服务器返回的 XML。</div></pre></td></tr></table></figure>
<h3 id="Ajax-的定义"><a href="#Ajax-的定义" class="headerlink" title="Ajax 的定义"></a>Ajax 的定义</h3><p>Ajax 是 Asynchronous JavaScript and XML（以及 DHTML 等）的缩写。这个短语是 Adaptive Path 的 Jesse James Garrett 发明的（请参阅 参考资料），按照 Jesse 的解释，这不是 个首字母缩写词。</p>
<h3 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h3><p>要了解的一个对象可能对您来说也是最陌生的，即 XMLHttpRequest。这是一个 JavaScript 对象，创建该对象很简单，如清单 1 所示。</p>
<h4 id="清单1-创建新的XMLHttpRequest-对象"><a href="#清单1-创建新的XMLHttpRequest-对象" class="headerlink" title="清单1.创建新的XMLHttpRequest 对象"></a>清单1.创建新的XMLHttpRequest 对象</h4><figure class="highlight plain"><figcaption><span>language="javascript" type="text/javascript">```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```var xmlHttp =new XMLHttpRequest();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下一期文章中将进一步讨论这个对象，现在要知道这是处理所有服务器通信的对象。继续阅读之前，先停下来想一想：通过 XMLHttpRequest 对象与服务器进行对话的是 JavaScript 技术。这不是一般的应用程序流，这恰恰是 Ajax 的强大功能的来源。</div><div class="line"></div><div class="line">然后，服务器将数据返回 JavaScript 代码（仍然在 Web 表单中），后者决定如何处理这些数据。它可以迅速更新表单数据，让人感觉应用程序是立即完成的，表单没有提交或刷新而用户得到了新数据。JavaScript 代码甚至可以对收到的数据执行某种计算，再发送另一个请求，完全不需要用户干预！这就是 XMLHttpRequest 的强大之处。它可以根据需要自行与服务器进行交互，用户甚至可以完全不知道幕后发生的一切。结果就是类似于桌面应用程序的动态、快速响应、高交互性的体验，但是背后又拥有互联网的全部强大力量。</div><div class="line"></div><div class="line">加入一些 JavaScript</div><div class="line"></div><div class="line">得到 XMLHttpRequest 的句柄后，其他的 JavaScript 代码就非常简单了。事实上，我们将使用 JavaScript 代码完成非常基本的任务：</div></pre></td></tr></table></figure>
<p>·获取表单数据：JavaScript 代码很容易从 HTML 表单中抽取数据并发送到服务器。<br>·修改表单上的数据：更新表单也很简单，从设置字段值到迅速替换图像。<br>·解析 HTML 和 XML：使用 JavaScript 代码操纵 DOM（请参阅 下一节），处理 HTML 表单服务器返回的 XML 数据的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#### 清单 2. 用 JavaScript 代码捕获和设置字段值</div><div class="line">// Get the value of the &quot;phone&quot; field and stuff it in a variable called phone</div><div class="line">var phone = document.getElementById(&quot;phone&quot;).value;</div><div class="line"></div><div class="line">// Set some values on a form using an array called response</div><div class="line">document.getElementById(&quot;order&quot;).value = response[0];</div><div class="line">document.getElementById(&quot;address&quot;).value = response[1];</div><div class="line"></div><div class="line">这里没有特别需要注意的地方，真是好极了！您应该认识到这里并没有非常复杂的东西。只要掌握了 XMLHttpRequest，Ajax 应用程序的其他部分就是如 清单 2 所示的简单 JavaScript 代码了，混合有少量的 HTML。同时，还要用一点儿 DOM，我们就来看看吧。</div><div class="line"></div><div class="line">以 DOM 结束</div><div class="line"></div><div class="line">最后还有 DOM，即文档对象模型。可能对有些读者来说 DOM 有点儿令人生畏，HTML 设计者很少使用它，即使 JavaScript 程序员也不大用到它，除非要完成某项高端编程任务。大量使用 DOM 的是 复杂的 Java 和 C/C++ 程序，这可能就是 DOM 被认为难以学习的原因。</div><div class="line"></div><div class="line">幸运的是，在 JavaScript 技术中使用 DOM 很容易，也非常直观。现在，按照常规也许应该说明如何使用 DOM，或者至少要给出一些示例代码，但这样做也可能误导您。即使不理会 DOM，仍然能深入地探讨 Ajax，这也是我准备采用的方法。以后的文章将再次讨论 DOM，现在只要知道可能需要 DOM 就可以了。当需要在 JavaScript 代码和服务器之间传递 XML 和改变 HTML 表单的时候，我们再深入研究 DOM。没有它也能做一些有趣的工作，因此现在就把 DOM 放到一边吧。</div><div class="line"></div><div class="line">#### 获取 Request 对象</div><div class="line">有了上面的基础知识后，我们来看看一些具体的例子。XMLHttpRequest 是 Ajax 应用程序的核心，而且对很多读者来说可能还比较陌生，我们就从这里开始吧。从 清单 1 可以看出，创建和使用这个对象非常简单，不是吗？等一等。</div><div class="line"></div><div class="line">还记得几年前的那些讨厌的浏览器战争吗？没有一样东西在不同的浏览器上得到同样的结果。不管您是否相信，这些战争仍然在继续，虽然规模较小。但令人奇怪的是，XMLHttpRequest 成了这场战争的牺牲品之一。因此获得 XMLHttpRequest 对象可能需要采用不同的方法。下面我将详细地进行解释。</div><div class="line">#### 清单 3. 在 Microsoft 浏览器上创建 XMLHttpRequest 对象</div></pre></td></tr></table></figure></p>
<p>var xmlHttp = false;<br>try {<br>  xmlHttp = new ActiveXObject(“Msxml2.XMLHTTP”);<br>} catch (e) {<br>  try {<br>    xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”);<br>  } catch (e2) {<br>    xmlHttp = false;<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">您对这些代码可能还不完全理解，但没有关系。当本系列文章结束的时候，您将对 JavaScript 编程、错误处理、条件编译等有更深的了解。现在只要牢牢记住其中的两行代码：</div><div class="line">xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</div><div class="line"></div><div class="line">和</div><div class="line"></div><div class="line">xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);。</div><div class="line"></div><div class="line">这两行代码基本上就是尝试使用一个版本的 MSXML 创建对象，如果失败则使用另一个版本创建该对象。不错吧？如果都不成功，则将 xmlHttp 变量设为 false，告诉您的代码出现了问题。如果出现这种情况，可能是因为安装了非 Microsoft 浏览器，需要使用不同的代码。</div><div class="line"></div><div class="line">#### 清单 4. 以支持多种浏览器的方式创建 XMLHttpRequest 对象</div></pre></td></tr></table></figure></p>
<p>/<em> Create a new XMLHttpRequest object to talk to the Web server </em>/<br>var xmlHttp = false;<br>/<em>@cc_on @</em>/<br>/<em>@if (@_jscript_version &gt;= 5)<br>try {<br>  xmlHttp = new ActiveXObject(“Msxml2.XMLHTTP”);<br>} catch (e) {<br>  try {<br>    xmlHttp = new ActiveXObject(“Microsoft.XMLHTTP”);<br>  } catch (e2) {<br>    xmlHttp = false;<br>  }<br>}<br>@end @</em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (!xmlHttp &amp;amp;&amp; typeof XMLHttpRequest != &apos;undefined&apos;) &#123;</div><div class="line">  xmlHttp = new XMLHttpRequest();</div><div class="line">&#125;</div><div class="line"></div><div class="line">现在先不管那些注释掉的奇怪符号，如 @cc_on，这是特殊的 JavaScript 编译器命令，将在下一期针对 XMLHttpRequest 的文章中详细讨论。这段代码的核心分为三步</div></pre></td></tr></table></figure></p>
<p>1、建立一个变量 xmlHttp 来引用即将创建的 XMLHttpRequest 对象。<br>2、尝试在 Microsoft 浏览器中创建该对象：<br>      1）尝试使用 Msxml2.XMLHTTP 对象创建它。<br>      2）如果失败，再尝试 Microsoft.XMLHTTP 对象。<br>2、如果仍然没有建立 xmlHttp，则以非 Microsoft 的方式创建该对象。<br>最后，xmlHttp 应该引用一个有效的 XMLHttpRequest 对象，无论运行什么样的浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">### Ajax 世界中的请求/响应</div><div class="line">现在我们介绍了 Ajax，对 XMLHttpRequest 对象以及如何创建它也有了基本的了解。如果阅读得很仔细，您可能已经知道与服务器上的 Web 应用程序打交道的是 JavaScript 技术，而不是直接提交给那个应用程序的 HTML 表单。</div><div class="line"></div><div class="line">还缺少什么呢？到底如何使用 XMLHttpRequest。因为这段代码非常重要，您编写的每个 Ajax 应用程序都要以某种形式使用它，先看看 Ajax 的基本请求/响应模型是什么样吧。</div><div class="line"></div><div class="line">发出请求</div><div class="line"></div><div class="line">您已经有了一个崭新的 XMLHttpRequest 对象，现在让它干点活儿吧。首先需要一个 Web 页面能够调用的 JavaScript 方法（比如当用户输入文本或者从菜单中选择一项时）。接下来就是在所有 Ajax 应用程序中基本都雷同的流程：</div></pre></td></tr></table></figure></p>
<p>1、从 Web 表单中获取需要的数据。<br>2、建立要连接的 URL。<br>3、打开到服务器的连接。<br>4、设置服务器在完成后要运行的函数。<br>5、发送请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 清单 5. 发出 Ajax 请求</div></pre></td></tr></table></figure></p>
<p>function callServer() {<br>  // Get the city and state from the web form<br>  var city = document.getElementById(“city”).value;<br>  var state = document.getElementById(“state”).value;<br>  // Only go on if there are values for both fields<br>  if ((city == null) || (city == “”)) return;<br>  if ((state == null) || (state == “”)) return;</p>
<p>  // Build the URL to connect to<br>  var url = “/scripts/getZipCode.php?city=” + escape(city) + “&amp;state=” + escape(state);</p>
<p>  // Open a connection to the server<br>  xmlHttp.open(“GET”, url, true);</p>
<p>  // Setup a function for the server to run when it’s done<br>  xmlHttp.onreadystatechange = updatePage;</p>
<p>  // Send the request<br>  xmlHttp.send(null);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其中大部分代码意义都很明确。开始的代码使用基本 JavaScript 代码获取几个表单字段的值。然后设置一个 PHP 脚本作为链接的目标。要注意脚本 URL 的指定方式，city 和 state（来自表单）使用简单的 GET 参数附加在 URL 之后。</div><div class="line"></div><div class="line">然后打开一个连接，这是您第一次看到使用 XMLHttpRequest。其中指定了连接方法（GET）和要连接的 URL。最后一个参数如果设为 true，那么将请求一个异步连接（这就是 Ajax 的由来）。如果使用 false，那么代码发出请求后将等待服务器返回的响应。如果设为 true，当服务器在后台处理请求的时候用户仍然可以使用表单（甚至调用其他 JavaScript 方法）。</div><div class="line"></div><div class="line">xmlHttp（要记住，这是 XMLHttpRequest 对象实例）的 onreadystatechange 属性可以告诉服务器在运行完成 后（可能要用五分钟或者五个小时）做什么。因为代码没有等待服务器，必须让服务器知道怎么做以便您能作出响应。在这个示例中，如果服务器处理完了请求，一个特殊的名为 updatePage() 的方法将被触发。</div><div class="line"></div><div class="line">最后，使用值 null 调用 send()。因为已经在请求 URL 中添加了要发送给服务器的数据（city 和 state），所以请求中不需要发送任何数据。这样就发出了请求，服务器按照您的要求工作。</div><div class="line"></div><div class="line">如果没有发现任何新鲜的东西，您应该体会到这是多么简单明了！除了牢牢记住 Ajax 的异步特性外，这些内容都相当简单。应该感激 Ajax 使您能够专心编写漂亮的应用程序和界面，而不用担心复杂的 HTTP 请求/响应代码。</div><div class="line"></div><div class="line">#### 清单 5 中的代码说明了 Ajax 的易用性。数据是简单的文本，可以作为请求 URL 的一部分。用 GET 而不是更复杂的 POST 发送请求。没有 XML 和要添加的内容头部，请求体中没有要发送的数据；换句话说，这就是 Ajax 的乌托邦。</div><div class="line">#####处理响应</div><div class="line">现在要面对服务器的响应了。现在只要知道两点：</div><div class="line"></div><div class="line">·什么也不要做，直到 xmlHttp.readyState 属性的值等于 4。 </div><div class="line">·服务器将把响应填充到 xmlHttp.responseText 属性中。 </div><div class="line"></div><div class="line">其中的第一点，即就绪状态，将在下一篇文章中详细讨论，您将进一步了解 HTTP 请求的阶段，可能比您设想的还多。现在只要检查一个特定的值（4）就可以了（下一期文章中还有更多的值要介绍）。第二点，使用 xmlHttp.responseText 属性获得服务器的响应，这很简单。清单 6 中的示例方法可供服务器根据 清单 5 中发送的数据调用。</div><div class="line"></div><div class="line">#### 清单 6. 处理服务器响应</div></pre></td></tr></table></figure></p>
<p>function updatePage() {<br>  if (xmlHttp.readyState == 4) {<br>    var response = xmlHttp.responseText;<br>    document.getElementById(“zipCode”).value = response;<br>  }<br>}<br>```</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/15/十大经典算法排序总结对比/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/15/十大经典算法排序总结对比/" itemprop="url">
                  JS家的排序算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-15T00:00:00+08:00">
                2016-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文作者：<a href="http://www.jianshu.com/p/1b4068ccd505" target="_blank" rel="external">不是小羊的肖恩</a></p>
<h2 id="十大经典算法排序总结对比"><a href="#十大经典算法排序总结对比" class="headerlink" title="十大经典算法排序总结对比"></a>十大经典算法排序总结对比</h2><p><img src="http://upload-images.jianshu.io/upload_images/1867034-1d3e43cdb301fc9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Generating"></p>
<p>####名词解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n: 数据规模</div><div class="line">k:“桶”的个数</div><div class="line">In-place: 占用常数内存，不占用额外内存</div><div class="line">Out-place: 占用额外内存</div><div class="line">稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同</div></pre></td></tr></table></figure></p>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><h4 id="冒泡排序须知："><a href="#冒泡排序须知：" class="headerlink" title="冒泡排序须知："></a>冒泡排序须知：</h4><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像Abandon在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。。。冒泡排序还有一种优化算法，就是立一个flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。。</p>
<h5 id="什么时候最快（Best-Cases）："><a href="#什么时候最快（Best-Cases）：" class="headerlink" title="什么时候最快（Best Cases）："></a>什么时候最快（Best Cases）：</h5><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊。。。。）</p>
<h5 id="什么时候最慢（Worst-Cases）："><a href="#什么时候最慢（Worst-Cases）：" class="headerlink" title="什么时候最慢（Worst Cases）："></a>什么时候最慢（Worst Cases）：</h5><p>当输入的数据是反序时（写一个for循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗。。。）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1867034-e19840224b331fae.gif?imageMogr2/auto-orient/strip" alt="Generating"></p>
<h4 id="冒泡排序JavaScript代码实现："><a href="#冒泡排序JavaScript代码实现：" class="headerlink" title="冒泡排序JavaScript代码实现："></a>冒泡排序JavaScript代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function bubbleSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    for (var i = 0; i &lt; len; i++) &#123;</div><div class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</div><div class="line">            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比</div><div class="line">                var temp = arr[j+1];        //元素交换</div><div class="line">                arr[j+1] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><h3 id="选择排序须知："><a href="#选择排序须知：" class="headerlink" title="选择排序须知："></a>选择排序须知：</h3><p>在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h4 id="选择排序动图演示："><a href="#选择排序动图演示：" class="headerlink" title="选择排序动图演示："></a>选择排序动图演示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/1867034-c6cc220cfb2b9ac8.gif?imageMogr2/auto-orient/strip" alt="Generating"></p>
<h5 id="选择排序JavaScript代码实现："><a href="#选择排序JavaScript代码实现：" class="headerlink" title="选择排序JavaScript代码实现："></a>选择排序JavaScript代码实现：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function selectionSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    var minIndex, temp;</div><div class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</div><div class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</div><div class="line">                minIndex = j;                 //将最小数的索引保存</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><h3 id="插入排序须知："><a href="#插入排序须知：" class="headerlink" title="插入排序须知："></a>插入排序须知：</h3><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了。。。<br>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。对于这种算法，得了懒癌的我就套用教科书上的一句经典的话吧：感兴趣的同学可以在课后自行研究。。。<br><img src="http://upload-images.jianshu.io/upload_images/1867034-d1537e355abdd298.gif?imageMogr2/auto-orient/strip" alt="Generating"></p>
<h4 id="插入排序JavaScript代码实现："><a href="#插入排序JavaScript代码实现：" class="headerlink" title="插入排序JavaScript代码实现："></a>插入排序JavaScript代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function insertionSort(arr) &#123;</div><div class="line">    var len = arr.length;</div><div class="line">    var preIndex, current;</div><div class="line">    for (var i = 1; i &lt; len; i++) &#123;</div><div class="line">        preIndex = i - 1;</div><div class="line">        current = arr[i];</div><div class="line">        while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">            arr[preIndex+1] = arr[preIndex];</div><div class="line">            preIndex--;</div><div class="line">        &#125;</div><div class="line">        arr[preIndex+1] = current;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><h3 id="希尔排序须知："><a href="#希尔排序须知：" class="headerlink" title="希尔排序须知："></a>希尔排序须知：</h3><p>希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。在这里，我就使用了这种方法。</p>
<h4 id="希尔排序JavaScript代码实现："><a href="#希尔排序JavaScript代码实现：" class="headerlink" title="希尔排序JavaScript代码实现："></a>希尔排序JavaScript代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function shellSort(arr) &#123;</div><div class="line">    var len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = 1;</div><div class="line">    while(gap &lt; len/3) &#123;          //动态定义间隔序列</div><div class="line">        gap =gap*3+1;</div><div class="line">    &#125;</div><div class="line">    for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123;</div><div class="line">        for (var i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="归并排序须知："><a href="#归并排序须知：" class="headerlink" title="归并排序须知："></a>归并排序须知：</h3><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<p>1、自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）<br>2、自下而上的迭代<br>在《数据结构与算法JavaScript描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">However, it is not possible to do so in JavaScript, as the recursion goes too deep</div><div class="line">for the language to handle.</div><div class="line">然而,在 JavaScript 中这种方式不太可行,因为这个算法的递归深度对它来讲太深了。</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/05/http/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Fenglin">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Feng~Lin">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Feng~Lin" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/05/http/" itemprop="url">
                  一个http请求发送到后端的详细过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-05T00:00:00+08:00">
                2015-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="title-一个http请求发送到后端的详细过程"><a href="#title-一个http请求发送到后端的详细过程" class="headerlink" title="title: 一个http请求发送到后端的详细过程"></a>title: 一个http请求发送到后端的详细过程</h2><p>http是一个应用层协议，在这个层的协议，只是一种通信规范，也就是因为双方要进行通讯，而约定俗成的一个规范。</p>
<h2 id="通讯步骤"><a href="#通讯步骤" class="headerlink" title="通讯步骤"></a>通讯步骤</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>当我们输入这样一个请求时，首先要建立一个socket连接，因为socket是通过ip和端口建立连接的所以之前还有一个DNS解析过程，把www.mycompany.com变成ip，如果url里不包含端口号，则会使用该协议的默认端口号。</p>
<p>DNS的过程是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">### 请求</div><div class="line">     连接成功建立后，开始向web服务器发送请求，这个请求一般是GET或POST命令（POST用于FORM参数的传递）。GET命令的格式为：　　GET 路径/文件名 HTTP/1.0</div><div class="line"></div><div class="line">     文件名指出所访问的文件，HTTP/1.0指出Web浏览器使用的HTTP版本。现在可以发送GET命令：</div><div class="line">### 应答</div><div class="line">    web服务器收到这个请求，进行处理。从它的文档空间中搜索子目录mydir的文件index.html。如果找到该文件，Web服务器把该文件内容传送给相应的Web浏览器。</div><div class="line"></div><div class="line">为了告知浏览器，，Web服务器首先传送一些HTTP头信息，然后传送具体内容（即HTTP体信息），HTTP头信息和HTTP体信息之间用一个空行分开。</div><div class="line">常用的HTTP头信息有：</div><div class="line">　　```① HTTP 1.0 200 OK 　这是Web服务器应答的第一行，列出服务器正在运行的HTTP版本号和应答代码。代码&quot;200 OK&quot;表示请求完成。</div></pre></td></tr></table></figure></p>
<p>　　<figure class="highlight plain"><figcaption><span>MIME_Version:1.0　它指示MIME类型的版本。　```　</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　```③ content_type:类型　这个头信息非常重要，它指示HTTP体信息的MIME类型。如：content_type:text/html指示传送的数据是HTML文档。</div></pre></td></tr></table></figure></p>
<p>　　<figure class="highlight plain"><figcaption><span>content_length:长度值　它指示HTTP体信息的长度（字节）。```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">### 关闭连接</div><div class="line">当应答结束后，Web浏览器与Web服务器必须断开，以保证其它Web浏览器能够与Web服务器建立连接。　　</div><div class="line">## tcp/ip基本模型及概念</div><div class="line">### 物理层</div><div class="line">设备，中继器（repeater）,集线器（hub）。对于这一层来说，从一个端口收到数据，会转发到所有端口。</div><div class="line">### 链路层</div><div class="line"></div><div class="line">协议：SDLC（Synchronous Data Link Control）HDLC（High-level Data Link Control） ppp协议独立的链路设备中最常见的当属网卡，网桥也是链路产品。集线器MODEM的某些功能有人认为属于链路层，对此还有些争议认为属于物理层设备。除此之外，所有的交换机都需要工作在数据链路层，但仅工作在数据链路层的仅是二层交换机。其他像三层交换机、四层交换机和七层交换机虽然可对应工作在OSI的三层、四层和七层，但二层功能仍是它们基本的功能。</div><div class="line"></div><div class="line">因为有了MAC地址表，所以才充分避免了冲突，因为交换机通过目的MAC地址知道应该把这个数据转发到哪个端口。而不会像HUB一样，会转发到所有滴端口。所以，交换机是可以划分冲突域滴。</div><div class="line">### 网络层</div><div class="line"></div><div class="line">四个主要的协议:   </div><div class="line">```网际协议IP：负责在主机和网络之间寻址和路由数据包。 ```    </div><div class="line">```地址解析协议ARP：获得同一物理网络中的硬件主机地址。   ```  </div><div class="line">```网际控制消息协议ICMP：发送消息，并报告有关数据包的传送错误。```     </div><div class="line">```互联组管理协议IGMP：被IP主机拿来向本地多路广播路由器报告主机组成员。</div></pre></td></tr></table></figure></p>
<p>该层设备有三层交换机，路由器。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>两个重要协议 TCP 和 UDP 。</p>
<p>端口概念：TCP/UDP 使用 IP 地址标识网上主机，使用端口号来标识应用进程，即 TCP/UDP 用主机 IP 地址和为应用进程分配的端口号来标识应用进程。端口号是 16 位的无符号整数， TCP 的端口号和 UDP 的端口号是两个独立的序列。尽管相互独立，如果 TCP 和 UDP 同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求。利用端口号，一台主机上多个进程可以同时使用 TCP/UDP 提供的传输服务，并且这种通信是端到端的，它的数据由 IP 传递，但与 IP 数据报的传递路径无关。网络通信中用一个三元组可以在全局唯一标志一个应用进程：（协议，本地地址，本地端口号）。</p>
<p>也就是说tcp和udp可以使用相同的端口。</p>
<p>可以看到通过(协议,源端口，源ip，目的端口，目的ip)就可以用来完全标识一组网络连接。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>基于tcp：Telnet FTP SMTP DNS HTTP<br>基于udp：RIP NTP（网落时间协议）和DNS （DNS也使用TCP）SNMP TFTP</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Fenglin" />
          <p class="site-author-name" itemprop="name">Fenglin</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">41</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fenglin</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
